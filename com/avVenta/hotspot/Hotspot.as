import mx.utils.Delegate;import com.avVenta.hotspot.*;import com.avVenta.events.BroadcastableMovieClip;dynamic class com.avVenta.hotspot.Hotspot extends BroadcastableMovieClip{	private static var BEGINSTATETRANSITION = "onBeginStateTransition";	private static var ENDSTATETRANSITION = "onEndStateTransition";	private static var ROLLOVER = "onRollOver";	private static var ROLLOUT = "onRollOut";	private static var RELEASE = "onRelease";	private static var CLOSE = "onClose";		private var label:String;	private var data:Object;		private var states:Object;	private var state:String = "";		private var newVisibleValue:Boolean = null;		private var hotspotAnimation: HotspotAnimationBase;		public static var animationType:String = "linear";	public static var animationTime:Number = 0.5;		private var _parent:HotspotsContainer;		private var mcHit:MovieClip;	private var mcContent: MovieClip;		private var stateTransitionInProgress:Boolean;	private var stateTransitionsQueue:Array;		private var isLoaded:Boolean;	private var isInitialized:Boolean;		public function Hotspot(){		this.stateTransitionInProgress = false;		this.stateTransitionsQueue = new Array();		this.hide();		this.states = new Object();				this.isLoaded = false;		this.isInitialized = false;				_parent.addEventListener( HotspotsContainer.HOTSPOTCONTENTSHOW, this, "onContainerShowHotspot");		_parent.addEventListener(HotspotsContainer.HOTSPOTCONTENTHIDE, this, "onContainerHideHotspot");		_parent.addEventListener(HotspotsContainer.SETHOTSPOTSSTATE, this, "onContainerSetHotspotsState");			}		public function init(label:String, data:Object){		this.isInitialized  = true;				this.label = label;		this.data = data;				//Listeners BBBB				if (this.isLoaded)			refreshHitArea();	}		private function onLoad(){		this.isLoaded = true;		//BBBB		hotspotAnimation.addEventListener("onShowRollOverBegin", this, "rollOverAnimationBegin");		hotspotAnimation.addEventListener("onShowRollOverEnd", this, "rollOverAnimationEnd");		hotspotAnimation.addEventListener("onHideRollOverBegin", this, "rollOutAnimationBegin");		hotspotAnimation.addEventListener("onHideRollOverEnd", this, "rollOutAnimationEnd");				hotspotAnimation.addEventListener("onShowContentBegin", this, "showContentBegin");		hotspotAnimation.addEventListener("onShowContentEnd", this, "showContentEnd");		hotspotAnimation.addEventListener("onHideContentBegin", this, "hideContentBegin");		hotspotAnimation.addEventListener("onHideContentEnd", this, "hideContentEnd");						if (this.isInitialized)			refreshHitArea();			}	public function addState(stateName: String, stateObject:Object){		this.states[stateName] = stateObject;	}		public function removeState(stateName: String){		delete this.states[stateName];	}		public function get actualState():String{		return this.state;	}		public function set actualState(newState:String){		changeState(newState);	}		private function createHitArea(){		var bounds = this.getBounds(this);		this.mcHit.lineStyle(0, 0x000000, 0);		this.mcHit.beginFill(0x000000, 0);		this.mcHit.moveTo(bounds.xMin, bounds.yMin);		this.mcHit.lineTo(bounds.xMax, bounds.yMin);		this.mcHit.lineTo(bounds.xMax, bounds.yMax);		this.mcHit.lineTo(bounds.xMin, bounds.yMax);		this.mcHit.lineTo(bounds.xMin, bounds.yMin);		this.mcHit.endFill();	}		private function removeHitArea(){		if (this.mcHit != undefined)			this.mcHit.clear();		else			this.mcHit = this.createEmptyMovieClip("mcHit", 1);	}		public function enable(){				this.mcHit.onRollOver = Delegate.create(this, MouseRollOver);		this.mcHit.onRollOut = Delegate.create(this, MouseRollOut);		this.mcHit.onRelease = Delegate.create(this, MouseRelease);						/*			public function onMouseDown(){		if (this.showingMenu){			if (!this.hitTest(_root._xmouse, _root._ymouse, true) && !this.dropDownMenu.hitTest(_root._xmouse, _root._ymouse, true) )				this.hideDropDownMenu();		}			}					*/			}		private function MouseRollOver(){		trace("rollover "+this+" - "+hotspotAnimation);		broadcastEvent(Hotspot.ROLLOVER);		hotspotAnimation.showRollOver();			}		private function MouseRollOut(){		broadcastEvent(Hotspot.ROLLOUT);		hotspotAnimation.hideRollOver();			}		private function MouseRelease(){		broadcastEvent(Hotspot.RELEASE);		hotspotAnimation.showContent();			}		private function rollOverAnimationBegin(){		//trace("A");	}	private function rollOverAnimationEnd(){		trace("B");		createHitArea();	}	private function rollOutAnimationBegin(){		//trace("C");	}	private function rollOutAnimationEnd(){		trace("D");		refreshHitArea();			}			private function refreshHitArea(){		disable();		removeHitArea();		createHitArea();		enable();		}		public function disable(){		delete this.mcHit.onRollOver;		delete this.mcHit.onRollOut;		delete this.mcHit.onRelease;			}		private function changeState(newState:String){		this.enqueueStateTransition(newState);		if (!this.stateTransitionInProgress){			this.createStateTransition(newState);		}	}		private function createStateTransition(newState:String){		this.stateTransitionInProgress = true;		this.broadcastEvent(Hotspot.BEGINSTATETRANSITION, {oldState: this.state, newState: newState});		var properties = [];		var values = [];		this.newVisibleValue = null;		for (var i in this.states[newState]){			if (i != "_visible"){				properties.push(i);				values.push(this.states[newState][i]);			}else{				if (this.states[newState][i])					this._visible = this.states[newState][i];				else					this.newVisibleValue = this.states[newState][i];			}					} 		this.state = newState;				this.tween(properties, values, Hotspot.animationTime, Hotspot.animationType, 0, mx.utils.Delegate.create(this, stateTransitionEnded) );	}		private function enqueueStateTransition(newState:String){		this.stateTransitionsQueue.push(newState);	}		private function stateTransitionEnded(){		this.broadcastEvent(Hotspot.ENDSTATETRANSITION, {newState: this.state});		if (this.newVisibleValue != null)			this._visible = this.newVisibleValue;		this.stateTransitionInProgress = false;		this.stateTransitionsQueue.shift();		if (this.stateTransitionsQueue.length > 0){			this.createStateTransition(this.stateTransitionsQueue[0]);		}	}		private function show(time:Number, animationType:String){		if (time == undefined){						if (this.states[this.state]._visible != false)				_visible = true;						if (this.states[this.state]._alpha != undefined)				_alpha = this.states[this.state]._alpha;			else				_alpha = 100;		}else{			if (animationType == undefined){				if (this.states[this.state]._visible != false)					_visible = true;				if (this.states[this.state]._alpha != undefined)					this.alphaTo(this.states[this.state]._alpha, time, "linear");				else					this.alphaTo(100, time, "linear");								}else{				if (this.states[this.state]._visible != false)					_visible = true;				if (this.states[this.state]._alpha != undefined)					this.alphaTo(this.states[this.state]._alpha, time, animationType);				else					this.alphaTo(100, time, animationType);							}		}	}		private function hide(time:Number, animationType:String){		if (time == undefined){			_visible = false;			_alpha = 0;		}else{			if (animationType == undefined){				this.alphaTo(100, time, "linear", 0, Delegate.create(this, onHideEnd));			}else{				this._visible = true;				this.alphaTo(100, time, animationType, 0, Delegate.create(this, onHideEnd));			}		}			}		private function onHideEnd(){		this._visible = false;	}		private function showContentBegin(source, evtObj){		disable();		_parent.broadcastEvent(HotspotsContainer.HOTSPOTCONTENTSHOW, {displayedHotspot: this});	}		private function showContentEnd(source, evtObj){		trace("Show content end");	}	private function hideContentBegin(source, evtObj){	}	private function hideContentEnd(source, evtObj){		trace("*** hide content end");		_parent.broadcastEvent(HotspotsContainer.HOTSPOTCONTENTHIDE, {displayedHotspot: this});		refreshHitArea();	}		private function onContainerShowHotspot(source, evtObj){		if (evtObj.displayedHotspot != this){			disable();			hide();		}	}		private function onContainerHideHotspot(source, evtObj){		if (evtObj.displayedHotspot != this){			enable();			show(0.25);		}	}			private function onContainerSetHotspotsState(source, evtObj){		this.actualState = evtObj.newState;	}		public function getParent():HotspotsContainer{		return _parent;	}		public function getData():Object{		return this.data;	}	public function getLabel():String{		return this.label;	}	}