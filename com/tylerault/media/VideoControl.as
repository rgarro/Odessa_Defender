import com.tylerault.gui.CustomButton;import com.tylerault.gui.Scrubber;import com.tylerault.gui.ToggleButton;import com.tylerault.media.VideoManager;import com.tylerault.utils.CallbackObject;import com.tylerault.utils.LogicUtils;/*** * Handles user interaction for controlling a video experience * * @author Tyler Ault [tault@digitas.com] ***/class com.tylerault.media.VideoControl{	public static var PLAY_STATE:Number = 0;	public static var PAUSE_STATE:Number = 1;	// play/pause behavior	public static var PLAY_PAUSE:Number = 0;	public static var REWIND_AND_PLAY:Number = 1;	private var container_mc:MovieClip;	private var manager:VideoManager;	private var playPauseButton:ToggleButton;	private var rewindButton:CustomButton;	private var timeScrubber:Scrubber;	private var loadBar_mc:MovieClip; // added for Saab standalone player	private var numCount:MovieClip;	private var hourCount:MovieClip;	private var weightmc:MovieClip;	private var storedPlayingValue:Boolean; // remembers for after scrubbing	private var scrubbing:Boolean;	private var timing:Boolean;	function VideoControl( newContainer_mc:MovieClip, newVideoManager:VideoManager )	{		this.container_mc = newContainer_mc;		this.manager = newVideoManager;		this.scrubbing = false;		this.timing = false;		// set up the play/pause button		setPlayPauseBehavior( VideoControl.PLAY_PAUSE );		// set up the rewind button		this.rewindButton = new CustomButton( this.container_mc.rewind_mc,			this, rewindPressed );		// set up the scrubber		if( LogicUtils.exists( this.container_mc.scrubTrack_mc ) )		{			/*this.timeScrubber = new Scrubber( this.container_mc.scrubTrack_mc,				this.container_mc.scrubBar_mc, this.container_mc.numberCounter_mc, null, new CallbackObject( this, scrubVideo ) );*/			this.timeScrubber = new Scrubber( this.container_mc.scrubTrack_mc,				this.container_mc.scrubBar_mc, null, new CallbackObject( this, scrubVideo ) );			// if a knob exists, set it			if( LogicUtils.exists( this.container_mc.scrubKnob_mc ) )			{ this.timeScrubber.setScrubKnob( this.container_mc.scrubKnob_mc ); }			// the loadBar shows the amount of video loaded			this.loadBar_mc = this.container_mc.loadBar_mc;			// when released, the video should start playing again			this.timeScrubber.setReleaseCallback(				new CallbackObject( this, resumeFromScrub ) );			// set the scrub track to update based on the video timeline			var updater:MovieClip = this.container_mc.scrubTrack_mc.createEmptyMovieClip(				"updater_mc", 100 );			updater.Callback = new CallbackObject( this, updateTimeScrubber );			updater.Callback.eachFrame( updater );		}		// TODO: add stop button	}	public function disableAll() : Void	{		this.playPauseButton.disable();		this.rewindButton.disable();	}	public function enableAll() : Void	{		this.playPauseButton.enable();		this.rewindButton.enable();	}	public function setPlayPauseState( Value:Number ) : Void	{		this.playPauseButton.setState( Value );	}	public function scrubVideo( percent:Number )	{		if( !LogicUtils.exists( this.storedPlayingValue ) )		{ this.storedPlayingValue = this.manager.getPlaying(); }		this.manager.setPlaying( false );		this.scrubbing = true;		var StreamDuration:Number = this.manager.getDuration(); 		this.manager.setSeconds( percent * StreamDuration );	}	public function updateTimeScrubber() : Void	{		if( this.loadBar_mc != undefined )		{			var bl:Number = this.manager.getBytesLoaded();			var bt:Number = this.manager.getBytesTotal();			var scrubLimit:Number = ( bt > 0 ) ? ( bl / bt ) : 0;			this.loadBar_mc._xscale = Math.round( scrubLimit * 100 );			// It was modify because the "scrubTrack_mc" turn gray			this.loadBar_mc._alpha = 0;			this.timeScrubber.setScrubLimit( scrubLimit );		}		if( this.scrubbing == false )		{			var percent:Number = this.manager.getSeconds() /					this.manager.getDuration();			this.timeScrubber.setPercentage( percent );			var TimeString1			//			//Converse the time properties (unite is second) of video stream to format--"hour: minute: second: millisecond", and then set them to corresponding text block.			//Here send the value of the time loaded every second			numCount = this.container_mc.numberCounter_mc;			var second:Number = this.manager.getSeconds();			var Hours:Number = Math.floor(this.manager.getSeconds()/3600);			var Residue = this.manager.getSeconds() % 3600;			var Minutes = Math.floor(Residue / 60);			Residue = Residue % 60;			var Seconds = Math.floor(Residue);			//Residue = Residue % 1;			//var Millisecond = Math.round(Residue * 1000);			var TimeString = (Minutes <10 ? ("0") : ("")) + Minutes + ":" + (Seconds <10 ? ("0") : ("")) + Seconds;																		if ( this.timing == false && this.manager.getDuration() != undefined && this.manager.getDuration() != "" && this.manager.getDuration() != null && this.manager.getDuration() != "NaN")			{				this.timing = true;				//Here send the value of the total time loaded				hourCount = this.container_mc.hourCounter_mc;				var Hours1:Number = Math.floor(this.manager.getDuration()/3600);				var Residue1 = this.manager.getDuration() % 3600;				var Minutes1 = Math.floor(Residue1 / 60);				Residue1 = Residue1 % 60;				var Seconds1 = Math.floor(Residue1);				//Residue = Residue % 1;				//var Millisecond = Math.round(Residue * 1000);				_global.TimeString1 = (Minutes1 <10 ? ("0") : ("")) + Minutes1 + ":" + (Seconds1 <10 ? ("0") : ("")) + Seconds1;							}						this.container_mc.timeCount.html = true			this.container_mc.timeCount.htmlText = TimeString + " / <font color='#00528E'>" + _global.TimeString1 + " min  " + Math.round(((this.manager.getBytesTotal())/1000)) + " KB</font>";								}			}	public function resumeFromScrub() : Void	{		if( this.storedPlayingValue == true )		{ this.manager.setPlaying( true ); }		this.storedPlayingValue = null;		this.scrubbing = false;	}	public function setBufferUpdater( handlerClip:MovieClip, bufferBar:MovieClip )	{		var TheVideoControl:VideoControl = this;		handlerClip.onEnterFrame = function ()		{			TheVideoControl.updateBufferIndicator.apply( TheVideoControl, [ this, bufferBar ] );		}	}	public function updateBufferIndicator( HandlerClip:MovieClip, bufferBar:MovieClip ) : Void	{		var bl:Number = this.manager.getNetStream().bytesLoaded;		var bt:Number = this.manager.getNetStream().bytesTotal;		bufferBar._xscale = Math.round( ( bl / bt ) * 100 );		_root.debug( "bl:bt  " + bl + ":" + bt + "  scale: " + bufferBar._xscale );		if( bl >= bt )		{			bufferBar._xscale = 100;			HandlerClip.onEnterFrame = null;		}	}	public function setPlayPauseBehavior( Behavior:Number ) : Void	{		delete this.playPauseButton;		switch ( Behavior )		{			case VideoControl.REWIND_AND_PLAY:				this.playPauseButton = new ToggleButton( this.container_mc.playPause_mc,						this, rewindPressed, [ true ], VideoControl.PLAY_STATE );			 				break;			default :				var StartState:Number = this.manager.getPlaying() ? 0 : 1;				this.playPauseButton = new ToggleButton( this.container_mc.playPause_mc,						this.manager, this.manager.togglePlay, null, StartState );			 		}	}	public function rewindPressed( resetPlayPause:Boolean ) : Void	{		this.manager.setSeconds( 0 );		if( resetPlayPause == true )		{ 		setPlayPauseBehavior(); 		this.playPauseButton.setState( 1 );		} // back to default behavior		//this.playPauseButton.setState( 1 );	}}